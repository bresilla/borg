use clap::{arg, Command, builder::styling};
use colored::Colorize;
// use std::path::PathBuf;

pub fn aly(letter: &str, show_logo: bool) -> String {
    let mut wrapped = "[ ".bright_green().to_string();
    wrapped.push_str(&letter.bright_green().bold().to_string());
    wrapped.push_str(&" ]".bright_green().to_string());
    wrapped.push_str(&"  ".to_string());
    let new_wrapped = if show_logo { wrapped } else { "".to_string() };
    new_wrapped
}

pub fn cli(subs: bool, logo: bool) -> Command {
    let logo: String = if logo {"
        ▄▄▄   ".bright_blue().to_string().to_owned()+"     ▄▄▄   ".bright_blue().to_string().as_str() + "     ▄▄▄     ".bright_green().to_string().as_str() + " 
      ▟█████▙ ".bright_blue().to_string().as_str() + "   ▟█████▙ ".bright_blue().to_string().as_str() + "   ▟█████▙   ".bright_green().to_string().as_str() + "   
      ▜█████▛ ".bright_blue().to_string().as_str() + "   ▜█████▛ ".bright_blue().to_string().as_str() + "   ▜█████▛   ".bright_green().to_string().as_str() + "   
        ▀▀▀   ".bright_blue().to_string().as_str() + "     ▀▀▀   ".bright_blue().to_string().as_str() + "     ▀▀▀     ".bright_green().to_string().as_str() + "   
        ▄▄▄   ".bright_blue().to_string().as_str() + "     ▄▄▄   ".bright_green().to_string().as_str() + "     ▄▄▄     ".bright_blue().to_string().as_str() + "   
      ▟█████▙ ".bright_blue().to_string().as_str() + "   ▟█████▙ ".bright_green().to_string().as_str() + "   ▟█████▙   ".bright_blue().to_string().as_str() + "   
      ▜█████▛ ".bright_blue().to_string().as_str() + "   ▜█████▛ ".bright_green().to_string().as_str() + "   ▜█████▛   ".bright_blue().to_string().as_str() + "   
        ▀▀▀   ".bright_blue().to_string().as_str() + "     ▀▀▀   ".bright_green().to_string().as_str() + "     ▀▀▀     ".bright_blue().to_string().as_str() + "   
        ▄▄▄   ".bright_blue().to_string().as_str() + "     ▄▄▄   ".bright_blue().to_string().as_str() + "     ▄▄▄     ".bright_green().to_string().as_str() + "   
      ▟█████▙ ".bright_blue().to_string().as_str() + "   ▟█████▙ ".bright_blue().to_string().as_str() + "   ▟█████▙   ".bright_green().to_string().as_str() + "   
      ▜█████▛ ".bright_blue().to_string().as_str() + "   ▜█████▛ ".bright_blue().to_string().as_str() + "   ▜█████▛   ".bright_green().to_string().as_str() + "   
        ▀▀▀   ".bright_blue().to_string().as_str() + "     ▀▀▀   ".bright_blue().to_string().as_str() + "     ▀▀▀     ".bright_green().to_string().as_str()} else { String::new() };


    let styles = styling::Styles::styled()
    .header(styling::AnsiColor::Blue.on_default() | styling::Effects::BOLD)
    .usage(styling::AnsiColor::Blue.on_default() | styling::Effects::BOLD)
    .literal(styling::AnsiColor::Green.on_default() | styling::Effects::BOLD)
    .error(styling::AnsiColor::Red.on_default() | styling::Effects::BOLD)
    .placeholder(styling::AnsiColor::Green.on_default());


    Command::new("borg")
        .before_help(&logo)
        .styles(styles)
        .about("a wannabe ros2 command line tool alternative") 
        .author("bresilla <trim.bresilla@gmail.com>")
        .version("1.0")
        .long_about("A ROS2 command line tool replacer that aims to be more user friendly and more powerful. [ALPHA STATE]")
        // .arg(arg!(--color <WHEN>)
        //     .value_parser(["always", "auto", "never"])
        //     .num_args(0..=1)
        //     .require_equals(true)
        //     .default_value("auto")
        //     .default_missing_value("always"))
        .subcommand_required(true)
        .arg_required_else_help(true)
        .allow_external_subcommands(false)
        .disable_help_subcommand(true)
        .subcommand(
            Command::new("action")
                .about(aly("a", subs) + "Various action subcommands")
                .aliases(&["a", "act"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand(
                    Command::new("info")
                    .about(" Print information about an action")
                    .aliases(["i", "show"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<ACTION_NAME> "Name of the ROS action to get info (e.g. '/fibonacci')")
                        .required(true)
                    )
                    .arg( arg!(-t --types "Additionally show the action type") )
                    .arg( arg!(-c --count "Only display the number of action clients and action servers") )
                )
                .subcommand(
                    Command::new("list")
                    .about("List all actions")
                    .aliases(["l", "ls"])
                    .arg_required_else_help(true)
                    .arg(arg!(-t --show_types "Additionally show the topic type"))
                    .arg(arg!(-c --count_topics "Only display the number of topics discovered"))
                )
                .subcommand(
                    Command::new("goal")
                    .about("Send a goal to an action server")
                    .aliases(["g", "send_goal"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<ACTION_NAME> "Name of the ROS action (e.g. '/fibonacci')")
                        .required(true)
                    )
                    .arg(
                        arg!(<ACTION_TYPE> "Type of the ROS action (e.g. 'example_interfaces/action/Fibonacci')")
                        .required(true)
                    )
                    .arg(
                        arg!(<GOAL> "Goal to send to the action server (e.g. '{order: 10}')")
                        .required(true)
                    )
                    .arg( arg!(-f --feedback "Echo feedback messages for the goal") )
                )
        )
        .subcommand(
            Command::new("topic")
                .about(aly("t", subs) + "Various topic subcommands")
                .aliases(&["t", "top"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand(
                    Command::new("echo")
                    .about("Print messages from topic to screen")
                    .aliases(["e", "cat"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_NAME> "Name of the ROS topic to echo (e.g. '/chatter')")
                        .required(true)
                    )
                    .arg(
                        arg!(<MESSAGE_TYPE> "Type of the ROS message (e.g. 'std_msgs/msg/String')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Time (sec) to spin. Default: until interrupted"))
                    .arg(arg!(-s --use_sim_time "Use simulation time if available"))
                    .arg(arg!(--no_daemon "Don't spawn or use running daemon"))
                    .arg(arg!(--qos_profile <QOS_PROFILE> "QoS preset profile (default: sensor_data)"))
                    .arg(arg!(--qos_depth <QOS_DEPTH> "Queue size setting (overrides QoS profile)"))
                    .arg(arg!(--qos_history <QOS_HISTORY> "History of samples setting (default: keep_last)"))
                    .arg(arg!(--qos_reliability <QOS_RELIABILITY> "Reliability setting (default: Auto match)"))
                    .arg(arg!(--qos_durability <QOS_DURABILITY> "Durability setting (default: Auto match)"))
                    .arg(arg!(--csv "Output fields separated by commas (for plotting)"))
                    .arg(arg!(--field <FIELD> "Echo selected field of a message"))
                    .arg(arg!(-f --full_length "Output all elements for arrays, bytes, and long strings"))
                    .arg(arg!(-l --truncate_length <TRUNCATE_LENGTH> "Length to truncate arrays/strings to (default: 128)"))
                    .arg(arg!(--no_arr "Don't print array fields"))
                    .arg(arg!(--no_str "Don't print string fields"))
                    .arg(arg!(--flow_style "Print collections in block style (not in csv)"))
                    .arg(arg!(--no_lost_messages "Don't report lost messages"))
                    .arg(arg!(--raw "Echo raw binary representation"))
                    .arg(arg!(--once "Print first message and exit"))
                )
                .subcommand(
                    Command::new("hz")
                    .about("Display publishing rate of topic")
                    .aliases(["h", "rate"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_NAME> "Name of the ROS topic to mnitor (e.g. '/chatter')")
                        .required(true)
                    )  
                    .arg(arg!(-w --window <WINDOW> "Window size for rate calculation (default: 10000)"))
                    .arg(arg!(--filter <EXPR> "Filter messages by Python expression"))
                    .arg(arg!(--wall_time "Calculate rate using wall time (useful when clock is not published)"))
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time in seconds for discovery (if daemon not in use)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS simulation time"))                    
                )
                .subcommand(
                    Command::new("info")
                    .about("Print information about a topic")
                    .aliases(["i", "show"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_NAME> "Name of the ROS topic to get info (e.g. '/chatter')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not in use)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS simulation time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(-v --verbose "Print detailed information about nodes, namespaces, topic types..."))                    
                )
                .subcommand(
                    Command::new("list")
                    .about("Output a list of available topics")
                    .aliases(["l", "ls"])
                    .arg_required_else_help(true)
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not in use)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS simulation time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(-t --show_types "Additionally show the topic type"))
                    .arg(arg!(-c --count_topics "Only display the number of topics discovered"))
                    .arg(arg!(--include_hidden_topics "Consider hidden topics as well"))
                )
                .subcommand(
                    Command::new("pub")
                    .about("Publish a message to a topic")
                    .aliases(["p", "publish"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_NAME> "Name of the ROS topic to publish to (e.g. '/chatter')")
                        .required(true)
                    )
                    .arg(
                        arg!(<MESSAGE_TYPE> "Type of the ROS message (e.g. 'std_msgs/msg/String')")
                        .required(true)
                    )
                    .arg(
                        arg!(<VALUES> "Values to fill the message with in YAML format (e.g. 'data: Hello World')")
                        .required(true)
                    )
                    .arg(arg!(-r --rate <RATE> "Publishing rate in Hz (default: 1)"))
                    .arg(arg!(-p --print <PRINT> "Print every N-th message (default: 1)"))
                    .arg(arg!(--once "Publish one message and exit"))
                    .arg(arg!(-t --times <TIMES> "Publish this many times and exit"))
                    .arg(arg!(-w --wait_matching_subscriptions <WAIT_MATCHING_SUBS> "Wait for specified matching subscriptions"))
                    .arg(arg!(--keep_alive <KEEP_ALIVE> "Keep node alive N sec after last message (default: 0.1)"))
                    .arg(arg!(-n --node_name <NODE_NAME> "Name of publishing node"))
                    .arg(arg!(--qos_profile <QOS_PROFILE> "QoS preset profile to publish"))
                    .arg(arg!(--qos_depth <QOS_DEPTH> "Queue size setting (overrides profile)"))
                    .arg(arg!(--qos_history <QOS_HISTORY> "History of samples setting (overrides profile, default: keep_last)"))
                    .arg(arg!(--qos_reliability <QOS_RELIABILITY> "QoS reliability setting (overrides profile, default: reliable)"))
                    .arg(arg!(--qos_durability <QOS_DURABILITY> "QoS durability setting (overrides profile, default: transient_local)"))
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                )
                .subcommand(
                    Command::new("kind")
                    .about("Print a topic's type/kind")
                    .aliases(["k", "type"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_NAME> "Name of the ROS topic to get type (e.g. '/chatter')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not in use)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS simulation time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                )
                .subcommand(
                    Command::new("bw")
                    .about("Display bandwidth used by topic")
                    .aliases(["b", "bandwidth"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_NAME> "Name of the ROS topic to get bandwidth (e.g. '/chatter')")
                        .required(true)
                    )
                    .arg(arg!(-w --window <WINDOW> "Window size for rate calculation (default: 10000)"))
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                )
                .subcommand(
                    Command::new("find")
                    .about("Output a list of available topics of a given type")
                    .aliases(["f", "lookup", "search"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_TYPE> "Name of the ROS topic type to filter for (e.g. 'std_msg/msg/String')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not in use)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS simulation time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(-c --count_topics "Only display the number of topics discovered"))
                    .arg(arg!(--include_hidden_topics "Consider hidden topics as well"))
                )
                .subcommand(
                    Command::new("delay")
                    .about("Display delay of topic from timestamp in header")
                    .aliases(["d", "latency"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TOPIC_NAME> "Name of the ROS topic to get delay (e.g. '/chatter')")
                        .required(true)
                    )
                    .arg(arg!(-w --window <WINDOW> "Window size for rate calculation (default: 10000)"))
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                )
        )
        .subcommand(
            Command::new("service")
                .about(aly("s", subs) + "Various service subcommands")
                .aliases(&["s", "ser"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand(
                    Command::new("call")
                    .about("Call a service")
                    .aliases(["c", "invoke"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<SERVICE_NAME> "Name of the ROS service to call to (e.g. '/add_two_ints')")
                        .required(true)
                    )
                    .arg(
                        arg!(<SERVICE_TYPE> "Type of the ROS service (e.g. 'std_srvs/srv/Empty')")
                        .required(true)
                    )
                    .arg(
                        arg!(<VALUES> "Values to fill the service request with in YAML format")
                        .required(true)
                    )
                    .arg(arg!(-r --rate <RATE> "Repeat the call at a specific rate in Hz"))
                )
                .subcommand(
                    Command::new("find")
                    .about("Output a list of available services of a given type")
                    .aliases(["f", "lookup", "search"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<SERVICE_TYPE> "Name of the ROS service type to filter for (e.g. 'std_srvs/srv/Empty')")
                        .required(true)
                    )
                    .arg(arg!(-c --count_services "Only display the number of services discovered"))
                    .arg(arg!(--include_hidden_services "Consider hidden services as well"))
                )
                .subcommand(
                    Command::new("list")
                    .about("Output a list of available services")
                    .aliases(["l", "ls"])
                    .arg_required_else_help(true)
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(-t --show_types "Show service type"))
                    .arg(arg!(-c --count_services "Display only the number of services discovered"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))
                )
                .subcommand(
                    Command::new("kind")
                    .about("Print a service's type")
                    .aliases(["k", "type"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<SERVICE_NAME> "Name of the ROS service to get type (e.g. '/add_two_ints')")
                        .required(true)
                    )
                )
        )
        .subcommand(
            Command::new("param")
                .about(aly("p", subs) + "Various param subcommands")
                .aliases(&["p", "par"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand(
                    Command::new("get")
                    .about("Get a parameter value")
                    .aliases(["g", "read"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to get parameter from (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(
                        arg!(<PARAM_NAME> "Name of the ROS parameter to get (e.g. 'use_sim_time')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))      
                    .arg(arg!(--hide_type "Hide the type information"))          
                )
                .subcommand(
                    Command::new("list")
                    .about("Output a list of available parameters")
                    .aliases(["l", "ls"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to get parameters from (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))      
                    .arg(arg!(--param_prefixes <PARAM_PREFIXES>... "Only list parameters with the provided prefixes"))                                                                                                                                                                                      
                    .arg(arg!(--param_type "Print parameter types with parameter names"))                     
                )
                .subcommand(
                    Command::new("set")
                    .about("Set a parameter value")
                    .aliases(["s", "assign"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to set parameter on (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(
                        arg!(<PARAM_NAME> "Name of the ROS parameter to set (e.g. 'use_sim_time')")
                        .required(true)
                    )
                    .arg(
                        arg!(<VALUE> "Value to set the parameter to (e.g. 'true')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))
                )
                .subcommand(
                    Command::new("export")
                    .about("Dump all parameters to a file")
                    .aliases(["e", "dump"])
                    .arg_required_else_help(true)   
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to set parameter on (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))
                    .arg(arg!(--output_dir <OUTPUT_DIR> "The absolute path where to save the generated file"))
                )
                .subcommand(
                    Command::new("remove")
                    .about("Remove a parameter")
                    .aliases(["r", "delete", "del", "rm"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to remove parameter from (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(
                        arg!(<PARAM_NAME> "Name of the ROS parameter to remove (e.g. 'use_sim_time')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))
                )
                .subcommand(
                    Command::new("describe")
                    .about("Show information about a parameter")
                    .aliases(["d", "info"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to describe parameter from (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(
                        arg!(<PARAM_NAME> "Name of the ROS parameter to describe (e.g. 'use_sim_time')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))
                )
                .subcommand(
                    Command::new("import")
                    .about("Load parameters from a file")
                    .aliases(["i", "load"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to import parameters to (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(
                        arg!(<PARAM_FILE> "Path to the file to load parameters from (e.g. '/home/user/params.yaml')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-s --use_sim_time "Enable ROS sim time"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))
                    .arg(arg!(--no_use_wildcard "Do not load parameters in the '/**' namespace into the node"))
                )
        )
        .subcommand(
            Command::new("node")
                .about(aly("n", subs) + "Various node subcommands")
                .aliases(&["n", "nod"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand(
                    Command::new("info")
                    .about("Print information about a node")
                    .aliases(["i", "show"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<NODE_NAME> "Name of the ROS node to get info (e.g. '/talker')")
                        .required(true)
                    )
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(--no_daemon "Don't spawn or use a running daemon"))
                    .arg(arg!(--include_hidden_services "Include hidden services"))
                )
                .subcommand(
                    Command::new("list")
                    .about("List all nodes")
                    .aliases(["l", "ls"])
                    .arg_required_else_help(true)
                    .arg(arg!(--spin_time <SPIN_TIME> "Spin time for discovery (if daemon not used)"))
                    .arg(arg!(-a --all "Display all nodes even hidden ones"))                                                                                                                                                                                                    
                    .arg(arg!(-c --count_nodes "Only display the number of nodes discovered"))
                )
        )
        .subcommand(
            Command::new("interface")
                .about(aly("i", subs) + "Various interface subcommands")
                .aliases(&["i", "int"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand(
                    Command::new("list")
                    .about("List all interface types available")
                    .aliases(["l", "ls"])
                    .arg_required_else_help(true)
                    .arg(arg!(-m --only_msgs "Print out only the message types"))
                    .arg(arg!(-s --only_srvs "Print out only the service types"))
                    .arg(arg!(-a --only_actions "Print out only the action types"))
                )
                .subcommand(
                    Command::new("package")
                    .about("Output a list of available interface types within one package")
                    .aliases(["p", "pkg"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<PACKAGE_NAME> "Name of the ROS package to get info (e.g. 'std_msgs')")
                        .required(true)
                    )
                )
                .subcommand(
                    Command::new("all")
                    .about("Output a list of available interface types within all packages")
                    .aliases(["a", "packages"])
                    .arg_required_else_help(true)
                    .arg(arg!(-m --only_msgs "Print out only the message types"))
                    .arg(arg!(-s --only_srvs "Print out only the service types"))
                    .arg(arg!(-a --only_actions "Print out only the action types"))
                )
                .subcommand(
                    Command::new("show")
                    .about("Show the interface definition for a given type")
                    .aliases(["s", "info"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<TYPE> "Show an interface definition (e.g. 'example_interfaces/msg/String'). Passing '-' reads the argument from stdin (e.g. 'ros2 topic type /chatter | ros2 interface show -').")
                        .required(true)
                    )
                    .arg(arg!(--all_comments "Show all comments, including for nested interface definitions"))
                    .arg(arg!(--no_comments "Show no comments or whitespace"))
                )
                .subcommand(
                    Command::new("model")
                    .about("Output an interface model/prototype")
                    .aliases(["m", "prototype", "proto"])
                    .arg_required_else_help(true)                                                                                                                                                                                                                      
                    .arg(
                        arg!(<TYPE> "Show an interface definition (e.g. 'example_interfaces/msg/String')")
                        .required(true)
                    )
                    .arg(arg!(--no_quotes "if true output has no outer quotes"))               
                )
        )
        .subcommand(
            Command::new("frame")
            .about(aly("f", subs) + "Various transforms subcommands [WIP]\n")
            .aliases(&["f", "tf"])
            .subcommand_required(true)
            .arg_required_else_help(true)
            .subcommand(
                Command::new("echo")
                .about("Print transforms from the tree to screen")
                .aliases(["e", "cat"])
                .arg_required_else_help(true)
                .arg(
                    arg!(<FRAME_ID> "Name of the frame id (e.g. 'odom')")
                    .required(true)
                )
                .arg(
                    arg!(<CHILD_FRAME_ID> "Name of the child frame id (e.g. 'base_link')")
                    .required(true)
                )
                .arg(arg!(--rate <RATE> "Rate at which to display transforms. Default: 10.0"))
                .arg(arg!(--once "Print first message and exit"))
            )
            .subcommand(
                Command::new("list")
                .about("Output a list of available frames")
                .aliases(["l", "ls"])
                .arg_required_else_help(true)
                .arg(arg!(-a --all "Display all frames even hidden ones"))
                .arg(arg!(-c --count_frames "Only display the number of frames discovered"))
            )
            .subcommand(
                Command::new("info")
                .about("Print information about a frame")
                .aliases(["i", "show"])
                .arg_required_else_help(true)
                .arg(
                    arg!(<FRAME_NAME> "Name of the frame to get info (e.g. 'base_link')")
                    .required(true)
                )
                .arg(arg!(--include_hidden_services "Include hidden services"))
                .arg(arg!(--export_dot <EXPORT_DOT> "Export the frame tree to a dot file").conflicts_with("export_json").conflicts_with("export_yaml"))
                .arg(arg!(--export_json <EXPORT_JSON> "Export the frame tree to a json file").conflicts_with("export_dot").conflicts_with("export_yaml"))
                .arg(arg!(--export_yaml <EXPORT_YAML> "Export the frame tree to a yaml file").conflicts_with("export_dot").conflicts_with("export_json"))
                .arg(arg!(--export_image <EXPORT_IMAGE> "Export the frame tree to an image file"))
            )
            .subcommand(
                Command::new("pub")
                .about("Publish a static transform")
                .aliases(["p", "publish"])
                .arg_required_else_help(true)
                .arg(
                    arg!(<FRAME_ID> "Name of the frame id (e.g. 'odom')")
                    .required(true)
                )
                .arg(
                    arg!(<CHILD_FRAME_ID> "Name of the child frame id (e.g. 'base_link')")
                    .required(true)
                )
                .arg(arg!(--x <X> "x component of translation"))
                .arg(arg!(--y <Y> "y component of translation"))
                .arg(arg!(--z <Z> "z component of translation"))
                .arg(arg!(--qx <QX> "x component of quaternion rotation").conflicts_with("roll").conflicts_with("pitch").conflicts_with("yaw"))
                .arg(arg!(--qy <QY> "y component of quaternion rotation").conflicts_with("roll").conflicts_with("pitch").conflicts_with("yaw"))
                .arg(arg!(--qz <QZ> "z component of quaternion rotation").conflicts_with("roll").conflicts_with("pitch").conflicts_with("yaw"))
                .arg(arg!(--qw <QW> "w component of quaternion rotation").conflicts_with("roll").conflicts_with("pitch").conflicts_with("yaw"))
                .arg(arg!(--roll <ROLL> "roll component Euler rotation").conflicts_with("qx").conflicts_with("qy").conflicts_with("qz").conflicts_with("qw"))
                .arg(arg!(--pitch <PITCH> "pitch component Euler rotation").conflicts_with("qx").conflicts_with("qy").conflicts_with("qz").conflicts_with("qw"))
                .arg(arg!(--yaw <YAW> "yaw component Euler rotation").conflicts_with("qx").conflicts_with("qy").conflicts_with("qz").conflicts_with("qw"))
            )
        )


        .subcommand(
            Command::new("run")
                .about(aly("r", subs) + "Run an executable")
                .aliases(&["r"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .arg(
                    arg!(<PACKAGE_NAME> "Name of the ROS package to run (e.g. 'demo_nodes_cpp')")
                    .required(true)
                )
                .arg(
                    arg!(<EXECUTABLE_NAME> "Name of the ROS executable to run (e.g. 'talker')")
                    .required(true)
                )
                .arg(
                    arg!(<ARGV> "Pass arbitrary arguments to the executable (e.g. '__log_level:=debug')")
                    .required(true)
                )
                .arg(arg!(--prefix <PREFIX> "Prefix command, which should go before the executable (e.g. --prefix 'gdb -ex run --args')"))
        )
        .subcommand(
            Command::new("launch")
                .about(aly("l", subs) + "Launch a launch file\n")
                .aliases(&["l"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .arg(
                    arg!(<PACKAGE_NAME> "Name of the ROS package which contains the launch file")
                    .required(true)
                )
                .arg(
                    arg!(<LAUNCH_FILE_NAME> "Name of the launch file")
                    .required(true)
                )
                .arg(
                    arg!(<LAUNCH_ARGUMENTS> "Arguments to the launch file; '<name>:=<value>' (for duplicates, last one wins)")
                    .required(true)
                )
                .arg(arg!(-n --noninteractive "Run the launch system non-interactively, with no terminal associated"))
                .arg(arg!(-d --debug "Put the launch system in debug mode, provides more verbose output."))
                .arg(arg!(-p --print "Print the launch description to the console without launching it."))
                .arg(arg!(-s --show_args "Show arguments that may be given to the launch file."))
                .arg(arg!(-a --show_all "Show all launched subprocesses' output"))
                .arg(arg!(--launch_prefix <LAUNCH_PREFIX> "Prefix command before executables (e.g. --launch-prefix 'xterm -e gdb -ex run --args')."))
                .arg(arg!(--launch_prefix_filter <LAUNCH_PREFIX_FILTER> "Regex pattern for executable filtering with --launch-prefix."))
        )

        .subcommand(
            Command::new("workspace")
                .about(aly("w", subs) + "Various workspace subcommands")
                .aliases(&["w", "pkg", "pack"])
                .subcommand_required(true)
                .arg_required_else_help(true)
                .subcommand(
                    Command::new("create")
                    .about("Create a new package")
                    .aliases(["c", "new"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<PACKAGE_NAME> "Name of the ROS package to create (e.g. 'demo_nodes_cpp')")
                        .required(true)
                    )
                    .arg(arg!(--package_format <PACKAGE_FORMAT> "The package.xml format."))
                    .arg(arg!(--description <DESCRIPTION> "The description given in the package.xml"))
                    .arg(arg!(--license <LICENSE> "The license attached to this package"))
                    .arg(arg!(--destination_directory <DESTINATION_DIRECTORY> "Directory where to create the package directory"))
                    .arg(arg!(--build_type <BUILD_TYPE> "The build type to process the package with"))
                    .arg(arg!(--dependencies <DEPENDENCIES>... "List of dependencies"))
                    .arg(arg!(--maintainer_email <MAINTAINER_EMAIL> "Email address of the maintainer of this package"))
                    .arg(arg!(--maintainer_name <MAINTAINER_NAME> "Name of the maintainer of this package"))
                    .arg(arg!(--node_name <NODE_NAME> "Name of the empty executable"))
                    .arg(arg!(--library_name <LIBRARY_NAME> "Name of the empty library"))
                )
                .subcommand(
                    Command::new("list")
                    .about("List all packages")
                    .aliases(["l", "ls"])
                    .arg_required_else_help(true)
                    .arg(arg!(-a --all "Display all packages even hidden ones"))
                    .arg(arg!(-c --count_packages "Only display the number of packages discovered"))
                )
                .subcommand(
                    Command::new("info")
                    .about("Print information about a package")
                    .aliases(["i", "show"])
                    .arg_required_else_help(true)
                    .arg(
                        arg!(<PACKAGE_NAME> "Name of the ROS package to get info (e.g. 'demo_nodes_cpp')")
                        .required(true)
                    )
                    .arg(arg!(--xml "Output the XML of the package manifest"))
                )
                .subcommand(
                    Command::new("build")
                    .about("Build a package")
                    .aliases(["b", "make", "m"])
                    .arg_required_else_help(true)
                )
        )

        .subcommand(
            Command::new("bag")
                .about(aly("b", subs) + "Various rosbag subcommands")
                .aliases(&["b"])
                .subcommand_required(true)
                .arg_required_else_help(true)
        )
        .subcommand(
            Command::new("middleware")
                .about(aly("m", subs) + "Various middleware subcommands [WIP]")
                .aliases(&["m"])
                .subcommand_required(true)
                .arg_required_else_help(true)
        )
}